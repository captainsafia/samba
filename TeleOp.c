#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S2,     IRSensor,              sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     armRight,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     armLeft,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     rearLeft,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     frontLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     rearRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     frontRight,    tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

void initializeRobot() {
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

  return;
}

int scaleForMotor(int joystickValue) {
	const int MAX_MOTOR_VALUE = 100;
	const float MAX_JOYSTICK_VALUE = 127.0;

	float ratio = joystickValue / MAX_JOYSTICK_VALUE;
	int scaledValue = ratio * MAX_MOTOR_VALUE;

	return scaledValue;

}

task main() {
  initializeRobot();

  waitForStart();   // wait for start of tele-op phase

  while (true) {
  	getJoystickSettings(joystick);

	if (abs(joystick.joy1_y1) > 10) {
		motor[frontLeft] = scaleForMotor(joystick.joy1_y1);
		motor[rearLeft] = scaleForMotor(joystick.joy1_y1);
	}

	if (abs(joystick.joy1_y2) > 10) {
		motor[frontRight] = scaleForMotor(joystick.joy1_y2);
		motor[rearRight] = scaleForMotor(joystick.joy1_y2);
	}

	if (joy1Btn(2) || joy1Btn(1)){
		motor[frontRight] = 0;
		motor[frontLeft] = 0;
		motor[rearLeft] = 0;
		motor[rearRight] = 0;
		motor[armLeft] = 0;
		motor[armRight] = 0;
	}

	if (joy1Btn(4)) {
		motor[armRight] = 45;
	}

	if (joy1Btn(3)) {
		motor[armRight] = -25;
	}
  }
}
