#pragma config(Hubs,	S1, HTMotor,	HTServo,	none,			none)
#pragma config(Sensor, S2,		 IRSensor,			 sensorI2CCustom)
#pragma config(Motor,	 mtr_S1_C1_1,			motorD,				 tmotorTetrix, openLoop)
#pragma config(Motor,	 mtr_S1_C1_2,			motorE,				 tmotorTetrix, openLoop)
#pragma config(Servo,	 srvo_S1_C2_1,		servo1,								tServoNone)
#pragma config(Servo,	 srvo_S1_C2_2,		servo2,								tServoNone)
#pragma config(Servo,	 srvo_S1_C2_3,		servo3,								tServoNone)
#pragma config(Servo,	 srvo_S1_C2_4,		servo4,								tServoNone)
#pragma config(Servo,	 srvo_S1_C2_5,		servo5,								tServoNone)
#pragma config(Servo,	 srvo_S1_C2_6,		servo6,								tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//													 Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"	 //Include file to "handle" the Bluetooth messages.
#include "drivers/HTIRS2-driver.h"


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																		initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//	 1. Move motors and servos to a preset position.
//	 2. Some sensor types take a short while to reach stable values during which time it is best that
//			robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//			"bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	// Place code here to sinitialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																				 Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//	 1. Have the robot follow a line on the game field until it reaches one of the puck storage
//			areas.
//	 2. Load pucks into the robot from the storage bin.
//	 3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();
	int _dirAC = 0;
	int acS1, acS2, acS3, acS4, acS5 = 0;

	tHTIRS2DSPMode _mode = DSP_1200;

	int maxSignal;
	int directional_value;

	if (HTIRS2setDSPMode(IRSensor, _mode) == 0 ) {
		nxtDisplayCenteredTextLine(0, "ERROR!");
		wait10Msec(300);
		} else {
		nxtDisplayCenteredTextLine(0, "Good to go!");
	}

	// waitForStart(); // Wait for the beginning of autonomous phase.

	///////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////
	////																									 ////
	////		Add your robot specific autonomous code here.	 ////
	////																									 ////
	///////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////

	while (true) {
		_dirAC = HTIRS2readACDir(IRSensor);
		if (_dirAC < 0) {
			nxtDisplayCenteredTextLine(0, "Oopsie-daisies");
			break;
			} else {
			nxtDisplayCenteredTextLine(0, "Fine and dandy, so - far");
		}

		if (!HTIRS2readAllACStrength(IRSensor, acS1, acS2, acS3, acS4, acS5 )) {
			writeDebugStreamLine("Error while reading signal!");
			break;
			} else {
				maxSignal = (acS1 > acS2) ? acS1 : acS2;
				maxSignal = (maxSignal > acS3) ? maxSignal : acS3;
				maxSignal = (maxSignal > acS4) ? maxSignal : acS4;
				maxSignal = (maxSignal > acS5) ? maxSignal : acS5;
				nxtDisplayCenteredTextLine(0, "%d", maxSignal);
				// A value of 2 or 3 is to the left of the mottor, a value of 8 or 9 is to the right
				nxtDisplayCenteredTextLine(1, "%d", _dirAC);
				wait10Msec(3);
		}
	}
}
